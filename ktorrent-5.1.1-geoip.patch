diff -up ktorrent-5.1.1/cmake/modules/FindMaxminddb.cmake.2~ ktorrent-5.1.1/cmake/modules/FindMaxminddb.cmake
--- ktorrent-5.1.1/cmake/modules/FindMaxminddb.cmake.2~	2019-05-11 22:29:42.001192270 +0200
+++ ktorrent-5.1.1/cmake/modules/FindMaxminddb.cmake	2019-05-11 22:29:42.001192270 +0200
@@ -0,0 +1,58 @@
+#=============================================================================
+# Copyright (c) 2019 Bernhard "Bero" Rosenkraenzer <bero@lindev.ch>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. The name of the author may not be used to endorse or promote products
+#    derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#=============================================================================
+
+find_package(PkgConfig QUIET)
+pkg_check_modules(PC_MAXMINDDB QUIET libmaxminddb)
+find_path(Maxminddb_INCLUDE_DIRS NAMES maxminddb.h
+	HINTS ${PC_MAXMINDDB_INCLUDEDIR}
+)
+find_library(Maxminddb_LIBRARIES NAMES maxminddb libmaxminddb
+	HINTS ${PC_MAXMINDDB_LIBRARY_DIRS}
+)
+set(Maxminddb_VERSION ${PC_MAXMINDDB_VERSION})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Maxminddb
+	FOUND_VAR Maxminddb_FOUND
+	REQUIRED_VARS Maxminddb_LIBRARIES Maxminddb_INCLUDE_DIRS
+	VERSION_VAR Maxminddb_VERSION
+)
+mark_as_advanced(Maxminddb_INCLUDE_DIRS Maxminddb_LIBRARIES)
+
+if(Maxminddb_FOUND AND NOT TARGET Maxminddb::Maxminddb)
+	add_library(Maxminddb::Maxminddb UNKNOWN IMPORTED)
+	set_target_properties(Maxminddb::Maxminddb PROPERTIES
+		IMPORTED_LOCATION "${Maxminddb_LIBRARIES}"
+		INTERFACE_INCLUDE_DIRECTORIES "${Maxminddb_INCLUDE_DIRS}"
+	)
+endif()
+
+include(FeatureSummary)
+set_package_properties(Maxminddb PROPERTIES
+	URL "https://dev.maxmind.com/maxmind-db/"
+	DESCRIPTION "GeoIP lookup support"
+)
diff -up ktorrent-5.1.1/plugins/infowidget/CMakeLists.txt.2~ ktorrent-5.1.1/plugins/infowidget/CMakeLists.txt
--- ktorrent-5.1.1/plugins/infowidget/CMakeLists.txt.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/CMakeLists.txt	2019-05-11 22:29:42.001192270 +0200
@@ -1,30 +1,11 @@
-# Add an option to compile & link against system GeoIP (off by default)
-option(WITH_SYSTEM_GEOIP 
-	"Link InfoWidget plugin against system GeoIP library and use system-wide default GeoIP Country database"
-	OFF)
-
-if (WITH_SYSTEM_GEOIP)
-	find_path(GEOIP_INCLUDE_DIR NAMES GeoIP.h PATHS / ${INCLUDE_INSTALL_DIR}/)
-	find_library(GEOIP_LIBRARY NAMES GeoIP PATHS ${KDE4_LIB_DIR} ${LIB_INSTALL_DIR})
-	
-	if (NOT GEOIP_INCLUDE_DIR OR NOT GEOIP_LIBRARY)
-		set(WITH_SYSTEM_GEOIP OFF CACHE BOOL
-		  "GeoIP development files could not be found on this system. Forcing this option to OFF"
-		  FORCE)
-		message(SEND_ERROR
-		  "GeoIP library development files could not be found on your system. Embedding a local copy of GeoIP instead")
-	endif(NOT GEOIP_INCLUDE_DIR OR NOT GEOIP_LIBRARY)
-endif(WITH_SYSTEM_GEOIP)
-
-if (WITH_SYSTEM_GEOIP)
-	message(STATUS "   Linking InfoWidget against system GeoIP library")
-	add_definitions( -DUSE_SYSTEM_GEOIP )
-	include_directories(GEOIP_INCLUDE_DIR)
-	set(geoip_link ${GEOIP_LIBRARY})
-else(WITH_SYSTEM_GEOIP)
-	message(STATUS "   Compiling GeoIP support directly into InfoWidget plugin")
-	set(geoip_src GeoIP.c)
-endif(WITH_SYSTEM_GEOIP)    
+find_package(Maxminddb)
+set_package_properties(Maxminddb
+	PROPERTIES
+	TYPE OPTIONAL
+	PURPOSE "Required for lookup of countries of peer IPs")
+if(Maxminddb_FOUND)
+	add_definitions(-DHAVE_MAXMINDDB)
+endif()
 
 set(ktinfowidgetplugin_SRC 
 	infowidgetplugin.cpp 
@@ -41,7 +22,6 @@ set(ktinfowidgetplugin_SRC
 	trackerview.cpp
 	trackermodel.cpp
 	addtrackersdialog.cpp
-	${geoip_src}
 	geoipmanager.cpp
 	flagdb.cpp
 	iwfiletreemodel.cpp
@@ -64,7 +44,8 @@ target_link_libraries(
     KF5::KIOFileWidgets
     KF5::KIOWidgets
     KF5::WidgetsAddons
-    ${geoip_link}
+    KF5::Archive
+    Maxminddb::Maxminddb
 )
 install(TARGETS ktorrent_infowidget DESTINATION ${KTORRENT_PLUGIN_INSTALL_DIR} )
 
diff -up ktorrent-5.1.1/plugins/infowidget/GeoIP.c.2~ ktorrent-5.1.1/plugins/infowidget/GeoIP.c
--- ktorrent-5.1.1/plugins/infowidget/GeoIP.c.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/GeoIP.c	2019-05-11 22:29:42.001192270 +0200
@@ -1,983 +0,0 @@
-/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*- */
-/* GeoIP.c
- *
- * Copyright (C) 2003 MaxMind LLC  All Rights Reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this library; if not, write to the Free Software
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include "GeoIP.h"
-
-#include <netdb.h>
-#include <sys/socket.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#ifndef _WIN32
-#include <netdb.h>
-#include <netinet/in.h> /* For ntohl */
-#include <arpa/inet.h>
-#else
-#include <windows.h>
-#endif
-#include <assert.h>
-#include <sys/types.h> /* for fstat */
-#include <sys/stat.h>   /* for fstat */
-
-#ifdef HAVE_STDINT_H
-#include <stdint.h>     /* For uint32_t */
-#endif
-
-#ifndef        INADDR_NONE
-#define        INADDR_NONE     -1
-#endif
-
-#define COUNTRY_BEGIN 16776960
-#define STATE_BEGIN_REV0 16700000
-#define STATE_BEGIN_REV1 16000000
-#define STRUCTURE_INFO_MAX_SIZE 20
-#define DATABASE_INFO_MAX_SIZE 100
-#define MAX_ORG_RECORD_LENGTH 300
-#define US_OFFSET 1
-#define CANADA_OFFSET 677
-#define WORLD_OFFSET 1353
-#define FIPS_RANGE 360
-
-#define CHECK_ERR(err, msg) { \
-        if (err != Z_OK) { \
-                fprintf(stderr, "%s error: %d\n", msg, err); \
-                exit(1); \
-        } \
-}
-
-const char GeoIP_country_code[247][3] = { "--", "AP", "EU", "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BM", "BN", "BO", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "FX", "GA", "GB", "GD", "GE", "GF", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IN", "IO", "IQ", "IR", "IS", "IT", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "ST", "SV", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TM", "TN", "TO", "TP", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "CS", "ZA", "ZM", "ZR", "ZW", "A1", "A2", "O1"};
-
-const char GeoIP_country_code3[247][4] = { "--", "AP", "EU", "AND", "ARE", "AFG", "ATG", "AIA", "ALB", "ARM", "ANT", "AGO", "AQ", "ARG", "ASM", "AUT", "AUS", "ABW", "AZE", "BIH", "BRB", "BGD", "BEL", "BFA", "BGR", "BHR", "BDI", "BEN", "BMU", "BRN", "BOL", "BRA", "BHS", "BTN", "BV", "BWA", "BLR", "BLZ", "CAN", "CC", "COD", "CAF", "COG", "CHE", "CIV", "COK", "CHL", "CMR", "CHN", "COL", "CRI", "CUB", "CPV", "CX", "CYP", "CZE", "DEU", "DJI", "DNK", "DMA", "DOM", "DZA", "ECU", "EST", "EGY", "ESH", "ERI", "ESP", "ETH", "FIN", "FJI", "FLK", "FSM", "FRO", "FRA", "FX", "GAB", "GBR", "GRD", "GEO", "GUF", "GHA", "GIB", "GRL", "GMB", "GIN", "GLP", "GNQ", "GRC", "GS", "GTM", "GUM", "GNB", "GUY", "HKG", "HM", "HND", "HRV", "HTI", "HUN", "IDN", "IRL", "ISR", "IND", "IO", "IRQ", "IRN", "ISL", "ITA", "JAM", "JOR", "JPN", "KEN", "KGZ", "KHM", "KIR", "COM", "KNA", "PRK", "KOR", "KWT", "CYM", "KAZ", "LAO", "LBN", "LCA", "LIE", "LKA", "LBR", "LSO", "LTU", "LUX", "LVA", "LBY", "MAR", "MCO", "MDA", "MDG", "MHL", "MKD", "MLI", "MMR", "MNG", "MAC", "MNP", "MTQ", "MRT", "MSR", "MLT", "MUS", "MDV", "MWI", "MEX", "MYS", "MOZ", "NAM", "NCL", "NER", "NFK", "NGA", "NIC", "NLD", "NOR", "NPL", "NRU", "NIU", "NZL", "OMN", "PAN", "PER", "PYF", "PNG", "PHL", "PAK", "POL", "SPM", "PCN", "PRI", "PSE", "PRT", "PLW", "PRY", "QAT", "REU", "ROU", "RUS", "RWA", "SAU", "SLB", "SYC", "SDN", "SWE", "SGP", "SHN", "SVN", "SJM", "SVK", "SLE", "SMR", "SEN", "SOM", "SUR", "STP", "SLV", "SYR", "SWZ", "TCA", "TCD", "TF", "TGO", "THA", "TJK", "TKL", "TLS", "TKM", "TUN", "TON", "TUR", "TTO", "TUV", "TWN", "TZA", "UKR", "UGA", "UM", "USA", "URY", "UZB", "VAT", "VCT", "VEN", "VGB", "VIR", "VNM", "VUT", "WLF", "WSM", "YEM", "YT", "SCG", "ZAF", "ZMB", "ZR", "ZWE", "A1", "A2", "O1"};
-
-const char* GeoIP_country_name[247] = {"N/A", "Asia/Pacific Region", "Europe", "Andorra", "United Arab Emirates", "Afghanistan", "Antigua and Barbuda", "Anguilla", "Albania", "Armenia", "Netherlands Antilles", "Angola", "Antarctica", "Argentina", "American Samoa", "Austria", "Australia", "Aruba", "Azerbaijan", "Bosnia and Herzegovina", "Barbados", "Bangladesh", "Belgium", "Burkina Faso", "Bulgaria", "Bahrain", "Burundi", "Benin", "Bermuda", "Brunei Darussalam", "Bolivia", "Brazil", "Bahamas", "Bhutan", "Bouvet Island", "Botswana", "Belarus", "Belize", "Canada", "Cocos (Keeling) Islands", "Congo, The Democratic Republic of the", "Central African Republic", "Congo", "Switzerland", "Cote D'Ivoire", "Cook Islands", "Chile", "Cameroon", "China", "Colombia", "Costa Rica", "Cuba", "Cape Verde", "Christmas Island", "Cyprus", "Czechia", "Germany", "Djibouti", "Denmark", "Dominica", "Dominican Republic", "Algeria", "Ecuador", "Estonia", "Egypt", "Western Sahara", "Eritrea", "Spain", "Ethiopia", "Finland", "Fiji", "Falkland Islands (Malvinas)", "Micronesia, Federated States of", "Faroe Islands", "France", "France, Metropolitan", "Gabon", "United Kingdom", "Grenada", "Georgia", "French Guiana", "Ghana", "Gibraltar", "Greenland", "Gambia", "Guinea", "Guadeloupe", "Equatorial Guinea", "Greece", "South Georgia and the South Sandwich Islands", "Guatemala", "Guam", "Guinea-Bissau", "Guyana", "Hong Kong", "Heard Island and McDonald Islands", "Honduras", "Croatia", "Haiti", "Hungary", "Indonesia", "Ireland", "Israel", "India", "British Indian Ocean Territory", "Iraq", "Iran, Islamic Republic of", "Iceland", "Italy", "Jamaica", "Jordan", "Japan", "Kenya", "Kyrgyzstan", "Cambodia", "Kiribati", "Comoros", "Saint Kitts and Nevis",
-                                       "Korea, Democratic People's Republic of", "Korea, Republic of", "Kuwait", "Cayman Islands", "Kazakhstan", "Lao People's Democratic Republic", "Lebanon", "Saint Lucia", "Liechtenstein", "Sri Lanka", "Liberia", "Lesotho", "Lithuania", "Luxembourg", "Latvia", "Libyan Arab Jamahiriya", "Morocco", "Monaco", "Moldova, Republic of", "Madagascar", "Marshall Islands", "Macedonia", "Mali", "Myanmar", "Mongolia", "Macau", "Northern Mariana Islands", "Martinique", "Mauritania", "Montserrat", "Malta", "Mauritius", "Maldives", "Malawi", "Mexico", "Malaysia", "Mozambique", "Namibia", "New Caledonia", "Niger", "Norfolk Island", "Nigeria", "Nicaragua", "Netherlands", "Norway", "Nepal", "Nauru", "Niue", "New Zealand", "Oman", "Panama", "Peru", "French Polynesia", "Papua New Guinea", "Philippines", "Pakistan", "Poland", "Saint Pierre and Miquelon", "Pitcairn Islands", "Puerto Rico", "Palestinian Territory", "Portugal", "Palau", "Paraguay", "Qatar", "Reunion", "Romania", "Russian Federation", "Rwanda", "Saudi Arabia", "Solomon Islands", "Seychelles", "Sudan", "Sweden", "Singapore", "Saint Helena", "Slovenia", "Svalbard and Jan Mayen", "Slovakia", "Sierra Leone", "San Marino", "Senegal", "Somalia", "Suriname", "Sao Tome and Principe", "El Salvador", "Syrian Arab Republic", "Swaziland", "Turks and Caicos Islands", "Chad", "French Southern Territories", "Togo", "Thailand", "Tajikistan", "Tokelau", "Turkmenistan", "Tunisia", "Tonga", "East Timor", "Turkey", "Trinidad and Tobago", "Tuvalu", "Taiwan", "Tanzania, United Republic of", "Ukraine", "Uganda", "United States Minor Outlying Islands", "United States", "Uruguay", "Uzbekistan", "Holy See (Vatican City State)", "Saint Vincent and the Grenadines", "Venezuela", "Virgin Islands, British", "Virgin Islands, U.S.", "Vietnam", "Vanuatu", "Wallis and Futuna", "Samoa", "Yemen", "Mayotte", "Serbia and Montenegro", "South Africa", "Zambia", "Zaire", "Zimbabwe",
-                                       "Anonymous Proxy", "Satellite Provider", "Other"
-                                      };
-
-const char GeoIP_country_continent[247][3] = {"--", "AS", "EU", "EU", "AS", "AS", "SA", "SA", "EU", "AS", "SA", "AF", "AN", "SA", "OC", "EU", "OC", "SA", "AS", "EU", "SA", "AS", "EU", "AF", "EU", "AS", "AF", "AF", "SA", "AS", "SA", "SA", "SA", "AS", "AF", "AF", "EU", "SA", "NA", "AS", "AF", "AF", "AF", "EU", "AF", "OC", "SA", "AF", "AS", "SA", "SA", "SA", "AF", "AS", "AS", "EU", "EU", "AF", "EU", "SA", "SA", "AF", "SA", "EU", "AF", "AF", "AF", "EU", "AF", "EU", "OC", "SA", "OC", "EU", "EU", "EU", "AF", "EU", "SA", "AS", "SA", "AF", "EU", "SA", "AF", "AF", "SA", "AF", "EU", "SA", "SA", "OC", "AF", "SA", "AS", "AF", "SA", "EU", "SA", "EU", "AS", "EU", "AS", "AS", "AS", "AS", "AS", "EU", "EU", "SA", "AS", "AS", "AF", "AS", "AS", "OC", "AF", "SA", "AS", "AS", "AS", "SA", "AS", "AS", "AS", "SA", "EU", "AS", "AF", "AF", "EU", "EU", "EU", "AF", "AF", "EU", "EU", "AF", "OC", "EU", "AF", "AS", "AS", "AS", "OC", "SA", "AF", "SA", "EU", "AF", "AS", "AF", "NA", "AS", "AF", "AF", "OC", "AF", "OC", "AF", "SA", "EU", "EU", "AS", "OC", "OC", "OC", "AS", "SA", "SA", "OC", "OC", "AS", "AS", "EU", "SA", "OC", "SA", "AS", "EU", "OC", "SA", "AS", "AF", "EU", "AS", "AF", "AS", "OC", "AF", "AF", "EU", "AS", "AF", "EU", "EU", "EU", "AF", "EU", "AF", "AF", "SA", "AF", "SA", "AS", "AF", "SA", "AF", "AF", "AF", "AS", "AS", "OC", "AS", "AF", "OC", "AS", "AS", "SA", "OC", "AS", "AF", "EU", "AF", "OC", "NA", "SA", "AS", "EU", "SA", "SA", "SA", "SA", "AS", "OC", "OC", "OC", "AS", "AF", "EU", "AF", "AF", "AF", "AF"};
-
-const char* GeoIPDBDescription[NUM_DB_TYPES] = {NULL, "GeoIP Country Edition", "GeoIP City Edition, Rev 1", "GeoIP Region Edition, Rev 1", "GeoIP ISP Edition", "GeoIP Organization Edition", "GeoIP City Edition, Rev 0", "GeoIP Region Edition, Rev 0", "GeoIP Proxy Edition", "GeoIP ASNum Edition", "GeoIP Netspeed Edition"};
-
-char* _GeoIP_full_path_to(const char* file_name)
-{
-    char* path = malloc(sizeof(char) * 1024);
-
-#ifndef _WIN32
-    memset(path, 0, sizeof(char) * 1024);
-    snprintf(path, sizeof(char) * 1024 - 1, "%s/%s", "/home/ivan/geoip.dat", file_name);
-#else
-    char buf[MAX_PATH], *p, *q = NULL;
-    int len;
-    memset(buf, 0, sizeof(buf));
-    len = GetModuleFileNameA(GetModuleHandle(NULL), buf, sizeof(buf) - 1);
-    for (p = buf + len; p > buf; p--)
-        if (*p == '\\')
-        {
-            if (!q)
-                q = p;
-            else
-                *p = '/';
-        }
-    *q = 0;
-    memset(path, 0, sizeof(char) * 1024);
-    snprintf(path, sizeof(char) * 1024 - 1, "%s/%s", buf, file_name);
-#endif
-
-    return path;
-}
-
-char** GeoIPDBFileName = NULL;
-
-void _GeoIP_setup_dbfilename()
-{
-    if (NULL == GeoIPDBFileName)
-    {
-        GeoIPDBFileName = malloc(sizeof(char*) * NUM_DB_TYPES);
-        memset(GeoIPDBFileName, 0, sizeof(char*) * NUM_DB_TYPES);
-
-        GeoIPDBFileName[GEOIP_COUNTRY_EDITION]      = _GeoIP_full_path_to("GeoIP.dat");
-        GeoIPDBFileName[GEOIP_REGION_EDITION_REV0]  = _GeoIP_full_path_to("GeoIPRegion.dat");
-        GeoIPDBFileName[GEOIP_REGION_EDITION_REV1]  = _GeoIP_full_path_to("GeoIPRegion.dat");
-        GeoIPDBFileName[GEOIP_CITY_EDITION_REV0]    = _GeoIP_full_path_to("GeoIPCity.dat");
-        GeoIPDBFileName[GEOIP_CITY_EDITION_REV1]    = _GeoIP_full_path_to("GeoIPCity.dat");
-        GeoIPDBFileName[GEOIP_ISP_EDITION]      = _GeoIP_full_path_to("GeoIPISP.dat");
-        GeoIPDBFileName[GEOIP_ORG_EDITION]      = _GeoIP_full_path_to("GeoIPOrg.dat");
-        GeoIPDBFileName[GEOIP_PROXY_EDITION]        = _GeoIP_full_path_to("GeoIPProxy.dat");
-        GeoIPDBFileName[GEOIP_ASNUM_EDITION]        = _GeoIP_full_path_to("GeoIPASNum.dat");
-        GeoIPDBFileName[GEOIP_NETSPEED_EDITION]     = _GeoIP_full_path_to("GeoIPNetSpeed.dat");
-    }
-}
-
-static
-int _file_exists(const char* file_name)
-{
-    struct stat file_stat;
-    return((stat(file_name, &file_stat) == 0) ? 1 : 0);
-}
-
-int GeoIP_db_avail(int type)
-{
-    const char* filePath;
-    if (type < 0 || type >= NUM_DB_TYPES)
-    {
-        return 0;
-    }
-    filePath = GeoIPDBFileName[type];
-    if (NULL == filePath)
-    {
-        return 0;
-    }
-    return _file_exists(filePath);
-}
-
-static
-void _setup_segments(GeoIP* gi)
-{
-    int i, j;
-    unsigned char delim[3];
-    unsigned char buf[SEGMENT_RECORD_LENGTH];
-
-    /* default to GeoIP Country Edition */
-    gi->databaseType = GEOIP_COUNTRY_EDITION;
-    gi->record_length = STANDARD_RECORD_LENGTH;
-    fseek(gi->GeoIPDatabase, -3l, SEEK_END);
-    for (i = 0; i < STRUCTURE_INFO_MAX_SIZE; i++)
-    {
-        fread(delim, 1, 3, gi->GeoIPDatabase);
-        if (delim[0] == 255 && delim[1] == 255 && delim[2] == 255)
-        {
-            fread(&gi->databaseType, 1, 1, gi->GeoIPDatabase);
-            if (gi->databaseType >= 106)
-            {
-                /* backwards compatibility with databases from April 2003 and earlier */
-                gi->databaseType -= 105;
-            }
-
-            if (gi->databaseType == GEOIP_REGION_EDITION_REV0)
-            {
-                /* Region Edition, pre June 2003 */
-                gi->databaseSegments = malloc(sizeof(int));
-                gi->databaseSegments[0] = STATE_BEGIN_REV0;
-            }
-            else if (gi->databaseType == GEOIP_REGION_EDITION_REV1)
-            {
-                /* Region Edition, post June 2003 */
-                gi->databaseSegments = malloc(sizeof(int));
-                gi->databaseSegments[0] = STATE_BEGIN_REV1;
-            }
-            else if (gi->databaseType == GEOIP_CITY_EDITION_REV0 ||
-                     gi->databaseType == GEOIP_CITY_EDITION_REV1 ||
-                     gi->databaseType == GEOIP_ORG_EDITION ||
-                     gi->databaseType == GEOIP_ISP_EDITION ||
-                     gi->databaseType == GEOIP_ASNUM_EDITION)
-            {
-                /* City/Org Editions have two segments, read offset of second segment */
-                gi->databaseSegments = malloc(sizeof(int));
-                gi->databaseSegments[0] = 0;
-                fread(buf, SEGMENT_RECORD_LENGTH, 1, gi->GeoIPDatabase);
-                for (j = 0; j < SEGMENT_RECORD_LENGTH; j++)
-                {
-                    gi->databaseSegments[0] += (buf[j] << (j * 8));
-                }
-                if (gi->databaseType == GEOIP_ORG_EDITION ||
-                        gi->databaseType == GEOIP_ISP_EDITION)
-                    gi->record_length = ORG_RECORD_LENGTH;
-            }
-            break;
-        }
-        else
-        {
-            fseek(gi->GeoIPDatabase, -4l, SEEK_CUR);
-        }
-    }
-    if (gi->databaseType == GEOIP_COUNTRY_EDITION ||
-            gi->databaseType == GEOIP_PROXY_EDITION ||
-            gi->databaseType == GEOIP_NETSPEED_EDITION)
-    {
-        gi->databaseSegments = malloc(sizeof(int));
-        gi->databaseSegments[0] = COUNTRY_BEGIN;
-    }
-}
-
-static
-int _check_mtime(GeoIP* gi)
-{
-    struct stat buf;
-
-    if (gi->flags & GEOIP_CHECK_CACHE)
-    {
-        if (fstat(fileno(gi->GeoIPDatabase), &buf) != -1)
-        {
-            if (buf.st_mtime > gi->mtime)
-            {
-                /* GeoIP Database file updated */
-                if (gi->flags & GEOIP_MEMORY_CACHE)
-                {
-                    /* reload database into memory cache */
-                    if (realloc(gi->cache, buf.st_size) != NULL)
-                    {
-                        if (fread(gi->cache, sizeof(unsigned char), buf.st_size, gi->GeoIPDatabase) != (size_t) buf.st_size)
-                        {
-                            fprintf(stderr, "Error reading file %s\n", gi->file_path);
-                            return -1;
-                        }
-                        gi->mtime = buf.st_mtime;
-                    }
-                }
-                else
-                {
-                    /* refresh filehandle */
-                    fclose(gi->GeoIPDatabase);
-                    if (gi->databaseSegments != NULL)
-                        free(gi->databaseSegments);
-                    gi->GeoIPDatabase = fopen(gi->file_path, "rb");
-                    if (gi->GeoIPDatabase == NULL)
-                    {
-                        fprintf(stderr, "Error Opening file %s\n", gi->file_path);
-                        return -1;
-                    }
-                    _setup_segments(gi);
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-unsigned int _GeoIP_seek_record(GeoIP* gi, unsigned long ipnum)
-{
-    int depth;
-    unsigned int x;
-    unsigned char stack_buffer[2 * MAX_RECORD_LENGTH];
-    const unsigned char* buf = (gi->cache == NULL) ? stack_buffer : NULL;
-    unsigned int offset = 0;
-
-    const unsigned char* p;
-    int j;
-
-    _check_mtime(gi);
-    for (depth = 31; depth >= 0; depth--)
-    {
-        if (gi->cache == NULL && gi->index_cache == NULL)
-        {
-            /* read from disk */
-            fseek(gi->GeoIPDatabase, (long)gi->record_length * 2 * offset, SEEK_SET);
-            fread(stack_buffer, gi->record_length, 2, gi->GeoIPDatabase);
-        }
-        else if (gi->index_cache == NULL)
-        {
-            /* simply point to record in memory */
-            buf = gi->cache + (long)gi->record_length * 2 * offset;
-        }
-        else
-        {
-            buf = gi->index_cache + (long)gi->record_length * 2 * offset;
-        }
-
-        if (ipnum & (1 << depth))
-        {
-            /* Take the right-hand branch */
-            if (gi->record_length == 3)
-            {
-                /* Most common case is completely unrolled and uses constants. */
-                x = (buf[3 * 1 + 0] << (0 * 8))
-                    + (buf[3 * 1 + 1] << (1 * 8))
-                    + (buf[3 * 1 + 2] << (2 * 8));
-
-            }
-            else
-            {
-                /* General case */
-                j = gi->record_length;
-                p = &buf[2 * j];
-                x = 0;
-                do
-                {
-                    x <<= 8;
-                    x += *(--p);
-                }
-                while (--j);
-            }
-
-        }
-        else
-        {
-            /* Take the left-hand branch */
-            if (gi->record_length == 3)
-            {
-                /* Most common case is completely unrolled and uses constants. */
-                x = (buf[3 * 0 + 0] << (0 * 8))
-                    + (buf[3 * 0 + 1] << (1 * 8))
-                    + (buf[3 * 0 + 2] << (2 * 8));
-            }
-            else
-            {
-                /* General case */
-                j = gi->record_length;
-                p = &buf[1 * j];
-                x = 0;
-                do
-                {
-                    x <<= 8;
-                    x += *(--p);
-                }
-                while (--j);
-            }
-        }
-
-        if (x >= gi->databaseSegments[0])
-        {
-            return x;
-        }
-        offset = x;
-    }
-
-    /* shouldn't reach here */
-    fprintf(stderr, "Error Traversing Database for ipnum = %lu - Perhaps database is corrupt?\n", ipnum);
-    return 0;
-}
-
-unsigned long _GeoIP_addr_to_num(const char* addr)
-{
-    int i;
-    char tok[4];
-    int octet;
-    int j = 0, k = 0;
-    unsigned long ipnum = 0;
-    char c = 0;
-
-    for (i = 0; i < 4; i++)
-    {
-        for (;;)
-        {
-            c = addr[k++];
-            if (c == '.' || c == '\0')
-            {
-                tok[j] = '\0';
-                octet = atoi(tok);
-                if (octet > 255)
-                    return 0;
-                ipnum += (octet << ((3 - i) * 8));
-                j = 0;
-                break;
-            }
-            else if (c >= '0' && c <= '9')
-            {
-                if (j > 2)
-                {
-                    return 0;
-                }
-                tok[j++] = c;
-            }
-            else
-            {
-                return 0;
-            }
-        }
-        if (c == '\0' && i < 3)
-        {
-            return 0;
-        }
-    }
-    return ipnum;
-}
-
-GeoIP* GeoIP_open_type(int type, int flags)
-{
-    GeoIP* gi;
-    const char* filePath;
-    if (type < 0 || type >= NUM_DB_TYPES)
-    {
-        printf("Invalid database type %d\n", type);
-        return NULL;
-    }
-    _GeoIP_setup_dbfilename();
-    filePath = GeoIPDBFileName[type];
-    if (filePath == NULL)
-    {
-        printf("Invalid database type %d\n", type);
-        return NULL;
-    }
-    gi = GeoIP_open(filePath, flags);
-    return gi;
-}
-
-GeoIP* GeoIP_new(int flags)
-{
-    GeoIP* gi;
-    _GeoIP_setup_dbfilename();
-    gi = GeoIP_open(GeoIPDBFileName[GEOIP_COUNTRY_EDITION], flags);
-    return gi;
-}
-
-GeoIP* GeoIP_open(const char* filename, int flags)
-{
-    struct stat buf;
-#ifdef _WIN32
-    WSADATA wsa;
-    if (WSAStartup(MAKEWORD(1, 1), &wsa) != 0)
-        return NULL;
-#endif
-    {
-        GeoIP* gi = (GeoIP*)malloc(sizeof(GeoIP));
-        if (gi == NULL)
-            return NULL;
-        gi->file_path = malloc(sizeof(char) * (strlen(filename) + 1));
-        if (gi->file_path == NULL)
-            return NULL;
-        strcpy(gi->file_path, filename);
-        gi->GeoIPDatabase = fopen(filename, "rb");
-        if (gi->GeoIPDatabase == NULL)
-        {
-            fprintf(stderr, "Error Opening file %s\n", filename);
-            free(gi->file_path);
-            free(gi);
-            return NULL;
-        }
-        else
-        {
-            if (flags & GEOIP_MEMORY_CACHE)
-            {
-                if (fstat(fileno(gi->GeoIPDatabase), &buf) == -1)
-                {
-                    fprintf(stderr, "Error stating file %s\n", filename);
-                    free(gi->file_path);
-                    free(gi);
-                    return NULL;
-                }
-                gi->mtime = buf.st_mtime;
-                gi->cache = (unsigned char*) malloc(sizeof(unsigned char) * buf.st_size);
-                if (gi->cache != NULL)
-                {
-                    if (fread(gi->cache, sizeof(unsigned char), buf.st_size, gi->GeoIPDatabase) != (size_t) buf.st_size)
-                    {
-                        fprintf(stderr, "Error reading file %s\n", filename);
-                        free(gi->cache);
-                        free(gi);
-                        return NULL;
-                    }
-                }
-            }
-            else
-            {
-                if (flags & GEOIP_CHECK_CACHE)
-                {
-                    if (fstat(fileno(gi->GeoIPDatabase), &buf) == -1)
-                    {
-                        fprintf(stderr, "Error stating file %s\n", filename);
-                        free(gi);
-                        return NULL;
-                    }
-                    gi->mtime = buf.st_mtime;
-                }
-                gi->cache = NULL;
-            }
-            gi->flags = flags;
-            _setup_segments(gi);
-            if (flags & GEOIP_INDEX_CACHE)
-            {
-                gi->index_cache = (unsigned char*) malloc(sizeof(unsigned char) * ((gi->databaseSegments[0] * (long)gi->record_length * 2)));
-                if (gi->index_cache != NULL)
-                {
-                    fseek(gi->GeoIPDatabase, 0, SEEK_SET);
-                    if (fread(gi->index_cache, sizeof(unsigned char), gi->databaseSegments[0] * (long)gi->record_length * 2, gi->GeoIPDatabase) != (size_t)(gi->databaseSegments[0] * (long)gi->record_length * 2))
-                    {
-                        fprintf(stderr, "Error reading file %s\n", filename);
-                        free(gi->index_cache);
-                        free(gi);
-                        return NULL;
-                    }
-                }
-            }
-            else
-            {
-                gi->index_cache = NULL;
-            }
-            return gi;
-        }
-    }
-}
-
-void GeoIP_delete(GeoIP* gi)
-{
-    if (gi->GeoIPDatabase != NULL)
-        fclose(gi->GeoIPDatabase);
-    if (gi->cache != NULL)
-        free(gi->cache);
-    if (gi->index_cache != NULL)
-        free(gi->index_cache);
-    if (gi->file_path != NULL)
-        free(gi->file_path);
-    if (gi->databaseSegments != NULL)
-        free(gi->databaseSegments);
-    free(gi);
-}
-
-const char* GeoIP_country_code_by_name(GeoIP* gi, const char* name)
-{
-    int country_id;
-    country_id = GeoIP_id_by_name(gi, name);
-    return (country_id > 0) ? GeoIP_country_code[country_id] : NULL;
-}
-
-const char* GeoIP_country_code3_by_name(GeoIP* gi, const char* name)
-{
-    int country_id;
-    country_id = GeoIP_id_by_name(gi, name);
-    return (country_id > 0) ? GeoIP_country_code3[country_id] : NULL;
-}
-
-const char* GeoIP_country_name_by_name(GeoIP* gi, const char* name)
-{
-    int country_id;
-    country_id = GeoIP_id_by_name(gi, name);
-    return (country_id > 0) ? GeoIP_country_name[country_id] : NULL;
-}
-
-unsigned long _GeoIP_lookupaddress(const char* host)
-{
-    unsigned long addr = inet_addr(host);
-    struct hostent phe2;
-    struct hostent* phe = &phe2;
-    char* buf = NULL;
-    int buflength = 16384;
-    int herr = 0;
-    int result = 0;
-#ifdef HAVE_GETHOSTBYNAME_R
-    buf = malloc(buflength);
-#endif
-    if (addr == INADDR_NONE)
-    {
-#ifdef HAVE_GETHOSTBYNAME_R
-        while (1)
-        {
-            /* we use gethostbyname_r here because it is thread-safe and gethostbyname is not */
-#ifdef GETHOSTBYNAME_R_RETURNS_INT
-            result = gethostbyname_r(host, &phe2, buf, buflength, &phe, &herr);
-#else
-            phe = gethostbyname_r(host, &phe2, buf, buflength, &herr);
-#endif
-            if (herr != ERANGE)
-                break;
-            if (result == 0)
-                break;
-            /* double the buffer if the buffer is too small */
-            buflength = buflength * 2;
-            buf = realloc(buf, buflength);
-        }
-#endif
-#ifndef HAVE_GETHOSTBYNAME_R
-        /* Some systems do not support gethostbyname_r, such as Mac OS X */
-        phe = gethostbyname(host);
-#endif
-        if (!phe || result != 0)
-        {
-            free(buf);
-            return 0;
-        }
-        addr = *((unsigned long*) phe->h_addr_list[0]);
-    }
-#ifdef HAVE_GETHOSTBYNAME_R
-    free(buf);
-#endif
-    return ntohl(addr);
-}
-
-int GeoIP_id_by_name(GeoIP* gi, const char* name)
-{
-    unsigned long ipnum;
-    int ret;
-    if (name == NULL)
-    {
-        return 0;
-    }
-    if (gi->databaseType != GEOIP_COUNTRY_EDITION && gi->databaseType != GEOIP_PROXY_EDITION && gi->databaseType != GEOIP_NETSPEED_EDITION)
-    {
-        printf("Invalid database type %s, expected %s\n", GeoIPDBDescription[(int)gi->databaseType], GeoIPDBDescription[GEOIP_COUNTRY_EDITION]);
-        return 0;
-    }
-    if (!(ipnum = _GeoIP_lookupaddress(name)))
-        return 0;
-    ret = _GeoIP_seek_record(gi, ipnum) - COUNTRY_BEGIN;
-    return ret;
-
-}
-
-const char* GeoIP_country_code_by_addr(GeoIP* gi, const char* addr)
-{
-    int country_id;
-    country_id = GeoIP_id_by_addr(gi, addr);
-    return (country_id > 0) ? GeoIP_country_code[country_id] : NULL;
-}
-
-const char* GeoIP_country_code3_by_addr(GeoIP* gi, const char* addr)
-{
-    int country_id;
-    country_id = GeoIP_id_by_addr(gi, addr);
-    return (country_id > 0) ? GeoIP_country_code3[country_id] : NULL;
-    return GeoIP_country_code3[country_id];
-}
-
-const char* GeoIP_country_name_by_addr(GeoIP* gi, const char* addr)
-{
-    int country_id;
-    country_id = GeoIP_id_by_addr(gi, addr);
-    return (country_id > 0) ? GeoIP_country_name[country_id] : NULL;
-    return GeoIP_country_name[country_id];
-}
-
-const char* GeoIP_country_name_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    int country_id;
-    country_id = GeoIP_id_by_ipnum(gi, ipnum);
-    return (country_id > 0) ? GeoIP_country_name[country_id] : NULL;
-}
-
-const char* GeoIP_country_code_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    int country_id;
-    country_id = GeoIP_id_by_ipnum(gi, ipnum);
-    return (country_id > 0) ? GeoIP_country_code[country_id] : NULL;
-}
-
-const char* GeoIP_country_code3_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    int country_id;
-    country_id = GeoIP_id_by_ipnum(gi, ipnum);
-    return (country_id > 0) ? GeoIP_country_code3[country_id] : NULL;
-}
-
-int GeoIP_country_id_by_addr(GeoIP* gi, const char* addr)
-{
-    return GeoIP_id_by_addr(gi, addr);
-}
-
-int GeoIP_country_id_by_name(GeoIP* gi, const char* host)
-{
-    return GeoIP_id_by_name(gi, host);
-}
-
-int GeoIP_id_by_addr(GeoIP* gi, const char* addr)
-{
-    unsigned long ipnum;
-    int ret;
-    if (addr == NULL)
-    {
-        return 0;
-    }
-    if (gi->databaseType != GEOIP_COUNTRY_EDITION &&
-            gi->databaseType != GEOIP_PROXY_EDITION &&
-            gi->databaseType != GEOIP_NETSPEED_EDITION)
-    {
-        printf("Invalid database type %s, expected %s\n",
-               GeoIPDBDescription[(int)gi->databaseType],
-               GeoIPDBDescription[GEOIP_COUNTRY_EDITION]);
-        return 0;
-    }
-    ipnum = _GeoIP_addr_to_num(addr);
-    ret = _GeoIP_seek_record(gi, ipnum) - COUNTRY_BEGIN;
-    return ret;
-}
-
-int GeoIP_id_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    int ret;
-    if (ipnum == 0)
-    {
-        return 0;
-    }
-    if (gi->databaseType != GEOIP_COUNTRY_EDITION &&
-            gi->databaseType != GEOIP_PROXY_EDITION &&
-            gi->databaseType != GEOIP_NETSPEED_EDITION)
-    {
-        printf("Invalid database type %s, expected %s\n",
-               GeoIPDBDescription[(int)gi->databaseType],
-               GeoIPDBDescription[GEOIP_COUNTRY_EDITION]);
-        return 0;
-    }
-    ret = _GeoIP_seek_record(gi, ipnum) - COUNTRY_BEGIN;
-    return ret;
-}
-
-char* GeoIP_database_info(GeoIP* gi)
-{
-    int i;
-    unsigned char buf[3];
-    char* retval;
-    int hasStructureInfo = 0;
-
-    if (gi == NULL)
-        return NULL;
-
-    _check_mtime(gi);
-    fseek(gi->GeoIPDatabase, -3l, SEEK_END);
-
-    /* first get past the database structure information */
-    for (i = 0; i < STRUCTURE_INFO_MAX_SIZE; i++)
-    {
-        fread(buf, 1, 3, gi->GeoIPDatabase);
-        if (buf[0] == 255 && buf[1] == 255 && buf[2] == 255)
-        {
-            hasStructureInfo = 1;
-            break;
-        }
-        fseek(gi->GeoIPDatabase, -4l, SEEK_CUR);
-    }
-    if (hasStructureInfo == 1)
-    {
-        fseek(gi->GeoIPDatabase, -3l, SEEK_CUR);
-    }
-    else
-    {
-        /* no structure info, must be pre Sep 2002 database, go back to end */
-        fseek(gi->GeoIPDatabase, -3l, SEEK_END);
-    }
-
-    for (i = 0; i < DATABASE_INFO_MAX_SIZE; i++)
-    {
-        fread(buf, 1, 3, gi->GeoIPDatabase);
-        if (buf[0] == 0 && buf[1] == 0 && buf[2] == 0)
-        {
-            retval = malloc(sizeof(char) * (i + 1));
-            if (retval == NULL)
-            {
-                return NULL;
-            }
-            fread(retval, 1, i, gi->GeoIPDatabase);
-            retval[i] = '\0';
-            return retval;
-        }
-        fseek(gi->GeoIPDatabase, -4l, SEEK_CUR);
-    }
-    return NULL;
-}
-
-/* GeoIP Region Edition functions */
-
-void GeoIP_assign_region_by_inetaddr(GeoIP* gi, unsigned long inetaddr, GeoIPRegion* region)
-{
-    unsigned int seek_region;
-
-    /* This also writes in the terminating NULs (if you decide to
-     * keep them) and clear any fields that are not set. */
-    memset(region, 0, sizeof(GeoIPRegion));
-
-    seek_region = _GeoIP_seek_record(gi, ntohl(inetaddr));
-
-    if (gi->databaseType == GEOIP_REGION_EDITION_REV0)
-    {
-        /* Region Edition, pre June 2003 */
-        seek_region -= STATE_BEGIN_REV0;
-        if (seek_region >= 1000)
-        {
-            region->country_code[0] = 'U';
-            region->country_code[1] = 'S';
-            region->region[0] = (char)((seek_region - 1000) / 26 + 65);
-            region->region[1] = (char)((seek_region - 1000) % 26 + 65);
-        }
-        else
-        {
-            memcpy(region->country_code, GeoIP_country_code[seek_region], 2);
-        }
-    }
-    else if (gi->databaseType == GEOIP_REGION_EDITION_REV1)
-    {
-        /* Region Edition, post June 2003 */
-        seek_region -= STATE_BEGIN_REV1;
-        if (seek_region < US_OFFSET)
-        {
-            /* Unknown */
-            /* we don't need to do anything here b/c we memset region to 0 */
-        }
-        else if (seek_region < CANADA_OFFSET)
-        {
-            /* USA State */
-            region->country_code[0] = 'U';
-            region->country_code[1] = 'S';
-            region->region[0] = (char)((seek_region - US_OFFSET) / 26 + 65);
-            region->region[1] = (char)((seek_region - US_OFFSET) % 26 + 65);
-        }
-        else if (seek_region < WORLD_OFFSET)
-        {
-            /* Canada Province */
-            region->country_code[0] = 'C';
-            region->country_code[1] = 'A';
-            region->region[0] = (char)((seek_region - CANADA_OFFSET) / 26 + 65);
-            region->region[1] = (char)((seek_region - CANADA_OFFSET) % 26 + 65);
-        }
-        else
-        {
-            /* Not US or Canada */
-            memcpy(region->country_code, GeoIP_country_code[(seek_region - WORLD_OFFSET) / FIPS_RANGE], 2);
-        }
-    }
-}
-
-static
-GeoIPRegion* _get_region(GeoIP* gi, unsigned long ipnum)
-{
-    GeoIPRegion* region;
-
-    region = malloc(sizeof(GeoIPRegion));
-    if (region)
-    {
-        GeoIP_assign_region_by_inetaddr(gi, htonl(ipnum), region);
-    }
-    return region;
-}
-
-GeoIPRegion* GeoIP_region_by_addr(GeoIP* gi, const char* addr)
-{
-    unsigned long ipnum;
-    if (addr == NULL)
-    {
-        return 0;
-    }
-    if (gi->databaseType != GEOIP_REGION_EDITION_REV0 &&
-            gi->databaseType != GEOIP_REGION_EDITION_REV1)
-    {
-        printf("Invalid database type %s, expected %s\n", GeoIPDBDescription[(int)gi->databaseType], GeoIPDBDescription[GEOIP_REGION_EDITION_REV1]);
-        return 0;
-    }
-    ipnum = _GeoIP_addr_to_num(addr);
-    return _get_region(gi, ipnum);
-}
-
-GeoIPRegion* GeoIP_region_by_name(GeoIP* gi, const char* name)
-{
-    unsigned long ipnum;
-    if (name == NULL)
-    {
-        return 0;
-    }
-    if (gi->databaseType != GEOIP_REGION_EDITION_REV0 &&
-            gi->databaseType != GEOIP_REGION_EDITION_REV1)
-    {
-        printf("Invalid database type %s, expected %s\n", GeoIPDBDescription[(int)gi->databaseType], GeoIPDBDescription[GEOIP_REGION_EDITION_REV1]);
-        return 0;
-    }
-    if (!(ipnum = _GeoIP_lookupaddress(name)))
-        return 0;
-    return _get_region(gi, ipnum);
-}
-
-GeoIPRegion* GeoIP_region_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    if (gi->databaseType != GEOIP_REGION_EDITION_REV0 &&
-            gi->databaseType != GEOIP_REGION_EDITION_REV1)
-    {
-        printf("Invalid database type %s, expected %s\n", GeoIPDBDescription[(int)gi->databaseType], GeoIPDBDescription[GEOIP_REGION_EDITION_REV1]);
-        return 0;
-    }
-    return _get_region(gi, ipnum);
-}
-
-void GeoIPRegion_delete(GeoIPRegion* gir)
-{
-    free(gir);
-}
-
-/* GeoIP Organization, ISP and AS Number Edition private method */
-static
-char* _get_name(GeoIP* gi, unsigned long ipnum)
-{
-    int seek_org;
-    char buf[MAX_ORG_RECORD_LENGTH];
-    char* org_buf, * buf_pointer;
-    int record_pointer;
-
-    if (gi->databaseType != GEOIP_ORG_EDITION &&
-            gi->databaseType != GEOIP_ISP_EDITION &&
-            gi->databaseType != GEOIP_ASNUM_EDITION)
-    {
-        printf("Invalid database type %s, expected %s\n", GeoIPDBDescription[(int)gi->databaseType], GeoIPDBDescription[GEOIP_ORG_EDITION]);
-        return 0;
-    }
-
-    seek_org = _GeoIP_seek_record(gi, ipnum);
-    if (seek_org == (int) gi->databaseSegments[0])
-        return NULL;
-
-    record_pointer = seek_org + (2 * gi->record_length - 1) * gi->databaseSegments[0];
-
-    if (gi->cache == NULL)
-    {
-        fseek(gi->GeoIPDatabase, record_pointer, SEEK_SET);
-        fread(buf, sizeof(char), MAX_ORG_RECORD_LENGTH, gi->GeoIPDatabase);
-        org_buf = malloc(sizeof(char) * (strlen(buf) + 1));
-        strcpy(org_buf, buf);
-    }
-    else
-    {
-        buf_pointer = (char*)gi->cache + (long)record_pointer;
-        org_buf = malloc(sizeof(char) * (strlen(buf_pointer) + 1));
-        strcpy(org_buf, buf_pointer);
-    }
-    return org_buf;
-}
-
-char* GeoIP_name_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    return _get_name(gi, ipnum);
-}
-
-char* GeoIP_name_by_addr(GeoIP* gi, const char* addr)
-{
-    unsigned long ipnum;
-    if (addr == NULL)
-    {
-        return 0;
-    }
-    ipnum = _GeoIP_addr_to_num(addr);
-    return _get_name(gi, ipnum);
-}
-
-char* GeoIP_name_by_name(GeoIP* gi, const char* name)
-{
-    unsigned long ipnum;
-    if (name == NULL)
-    {
-        return 0;
-    }
-    if (!(ipnum = _GeoIP_lookupaddress(name)))
-        return 0;
-    return _get_name(gi, ipnum);
-}
-
-char* GeoIP_org_by_ipnum(GeoIP* gi, unsigned long ipnum)
-{
-    return GeoIP_name_by_ipnum(gi, ipnum);
-}
-
-char* GeoIP_org_by_addr(GeoIP* gi, const char* addr)
-{
-    return GeoIP_name_by_addr(gi, addr);
-}
-
-char* GeoIP_org_by_name(GeoIP* gi, const char* name)
-{
-    return GeoIP_name_by_name(gi, name);
-}
-
-unsigned char GeoIP_database_edition(GeoIP* gi)
-{
-    return gi->databaseType;
-}
diff -up ktorrent-5.1.1/plugins/infowidget/GeoIP.h.2~ ktorrent-5.1.1/plugins/infowidget/GeoIP.h
--- ktorrent-5.1.1/plugins/infowidget/GeoIP.h.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/GeoIP.h	2019-05-11 22:29:42.001192270 +0200
@@ -1,167 +0,0 @@
-/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*- */
-/* GeoIP.h
- *
- * Copyright (C) 2003 MaxMind LLC
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this library; if not, write to the Free Software
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#ifndef GEOIP_H
-#define GEOIP_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include<stdio.h>
-#include<stdlib.h>
-#include<string.h>
-#include <sys/types.h> /* for fstat */
-#include <sys/stat.h>   /* for fstat */
-
-#define SEGMENT_RECORD_LENGTH 3
-#define STANDARD_RECORD_LENGTH 3
-#define ORG_RECORD_LENGTH 4
-#define MAX_RECORD_LENGTH 4
-#define NUM_DB_TYPES 16
-
-    typedef struct GeoIPTag
-    {
-        FILE* GeoIPDatabase;
-        char* file_path;
-        unsigned char* cache;
-        unsigned char* index_cache;
-        unsigned int* databaseSegments;
-        char databaseType;
-        time_t mtime;
-        int flags;
-        char record_length;
-        int record_iter; /* used in GeoIP_next_record */
-    } GeoIP;
-
-    typedef struct GeoIPRegionTag
-    {
-        char country_code[3];
-        char region[3];
-    } GeoIPRegion;
-
-    typedef enum
-    {
-        GEOIP_STANDARD = 0,
-        GEOIP_MEMORY_CACHE = 1,
-        GEOIP_CHECK_CACHE = 2,
-        GEOIP_INDEX_CACHE = 4
-    } GeoIPOptions;
-
-    typedef enum
-    {
-        GEOIP_COUNTRY_EDITION     = 1,
-        GEOIP_REGION_EDITION_REV0 = 7,
-        GEOIP_CITY_EDITION_REV0   = 6,
-        GEOIP_ORG_EDITION         = 5,
-        GEOIP_ISP_EDITION         = 4,
-        GEOIP_CITY_EDITION_REV1   = 2,
-        GEOIP_REGION_EDITION_REV1 = 3,
-        GEOIP_PROXY_EDITION       = 8,
-        GEOIP_ASNUM_EDITION       = 9,
-        GEOIP_NETSPEED_EDITION   = 10
-    } GeoIPDBTypes;
-
-    typedef enum
-    {
-        GEOIP_ANON_PROXY = 1,
-        GEOIP_HTTP_X_FORWARDED_FOR_PROXY = 2,
-        GEOIP_HTTP_CLIENT_IP_PROXY = 3
-    } GeoIPProxyTypes;
-
-    typedef enum
-    {
-        GEOIP_UNKNOWN_SPEED = 0,
-        GEOIP_DIALUP_SPEED = 1,
-        GEOIP_CABLEDSL_SPEED = 2,
-        GEOIP_CORPORATE_SPEED = 3
-    } GeoIPNetspeedValues;
-
-    extern char** GeoIPDBFileName;
-    extern const char* GeoIPDBDescription[NUM_DB_TYPES];
-    extern const char* GeoIPCountryDBFileName;
-    extern const char* GeoIPRegionDBFileName;
-    extern const char* GeoIPCityDBFileName;
-    extern const char* GeoIPOrgDBFileName;
-    extern const char* GeoIPISPDBFileName;
-
-    extern const char GeoIP_country_code[247][3];
-    extern const char GeoIP_country_code3[247][4];
-    extern const char* GeoIP_country_name[247];
-    extern const char GeoIP_country_continent[247][3];
-
-#ifdef DLL
-#define GEOIP_API __declspec(dllexport)
-#else
-#define GEOIP_API
-#endif  /* DLL */
-
-    GEOIP_API GeoIP* GeoIP_open_type(int type, int flags);
-    GEOIP_API GeoIP* GeoIP_new(int flags);
-    GEOIP_API GeoIP* GeoIP_open(const char* filename, int flags);
-    GEOIP_API int GeoIP_db_avail(int type);
-    GEOIP_API void GeoIP_delete(GeoIP* gi);
-    GEOIP_API const char* GeoIP_country_code_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API const char* GeoIP_country_code_by_name(GeoIP* gi, const char* host);
-    GEOIP_API const char* GeoIP_country_code3_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API const char* GeoIP_country_code3_by_name(GeoIP* gi, const char* host);
-    GEOIP_API const char* GeoIP_country_name_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API const char* GeoIP_country_name_by_name(GeoIP* gi, const char* host);
-    GEOIP_API const char* GeoIP_country_name_by_ipnum(GeoIP* gi, unsigned long ipnum);
-    GEOIP_API const char* GeoIP_country_code_by_ipnum(GeoIP* gi, unsigned long ipnum);
-    GEOIP_API const char* GeoIP_country_code3_by_ipnum(GeoIP* gi, unsigned long ipnum);
-
-    /* Deprecated - for backwards compatibility only */
-    GEOIP_API int GeoIP_country_id_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API int GeoIP_country_id_by_name(GeoIP* gi, const char* host);
-    GEOIP_API char* GeoIP_org_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API char* GeoIP_org_by_name(GeoIP* gi, const char* host);
-    /* End deprecated */
-
-    GEOIP_API int GeoIP_id_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API int GeoIP_id_by_name(GeoIP* gi, const char* host);
-    GEOIP_API int GeoIP_id_by_ipnum(GeoIP* gi, unsigned long ipnum);
-
-    GEOIP_API GeoIPRegion* GeoIP_region_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API GeoIPRegion* GeoIP_region_by_name(GeoIP* gi, const char* host);
-    GEOIP_API GeoIPRegion* GeoIP_region_by_ipnum(GeoIP* gi, unsigned long ipnum);
-
-    /* Warning - don't call this after GeoIP_assign_region_by_inetaddr calls */
-    GEOIP_API void GeoIPRegion_delete(GeoIPRegion* gir);
-
-    GEOIP_API void GeoIP_assign_region_by_inetaddr(GeoIP* gi, unsigned long inetaddr, GeoIPRegion* gir);
-
-    /* Used to query GeoIP Organization, ISP and AS Number databases */
-    GEOIP_API char* GeoIP_name_by_ipnum(GeoIP* gi, unsigned long ipnum);
-    GEOIP_API char* GeoIP_name_by_addr(GeoIP* gi, const char* addr);
-    GEOIP_API char* GeoIP_name_by_name(GeoIP* gi, const char* host);
-
-    GEOIP_API char* GeoIP_database_info(GeoIP* gi);
-    GEOIP_API unsigned char GeoIP_database_edition(GeoIP* gi);
-
-#ifdef BSD
-#define memcpy(dest, src, n) bcopy(src, dest, n)
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* GEOIP_H */
diff -up ktorrent-5.1.1/plugins/infowidget/geoipmanager.cpp.2~ ktorrent-5.1.1/plugins/infowidget/geoipmanager.cpp
--- ktorrent-5.1.1/plugins/infowidget/geoipmanager.cpp.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/geoipmanager.cpp	2019-05-11 22:44:01.874662006 +0200
@@ -1,6 +1,7 @@
 /***************************************************************************
  *   Copyright (C) 2009 by Joris Guisson                                   *
  *   joris.guisson@gmail.com                                               *
+ *   Copyright (C) 2019 by Bernhard "Bero" Rosenkraenzer <bero@lindev.ch>  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -18,12 +19,16 @@
  *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
  ***************************************************************************/
 
+#ifdef HAVE_MAXMINDDB
 #include <KIO/CopyJob>
+#include <KTar>
+#endif
 
 #include <QDateTime>
 #include <QFile>
 #include <QFileInfo>
 #include <QStandardPaths>
+#include <QLocale>
 
 #include <util/log.h>
 #include <util/decompressfilejob.h>
@@ -35,16 +40,45 @@ using namespace bt;
 
 namespace kt
 {
-    QUrl GeoIPManager::geoip_url = QUrl(QStringLiteral("http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz"));
+#ifdef HAVE_MAXMINDDB
+    void UntarThread::run() {
+        KTar tar(src);
+        if(!tar.open(QIODevice::ReadOnly)) {
+            Out(SYS_INW | LOG_IMPORTANT) << "Failed to open GeoIP database tarball" << endl;
+            return;
+        }
+        scanDir(tar.directory());
+        tar.close();
+        QFile::remove(src);
+    }
+
+    void UntarThread::scanDir(const KArchiveDirectory *dir) {
+        for(const QString &entry: dir->entries()) {
+            if(dir->entry(entry)->isFile() && entry.endsWith(QFile::decodeName(".mmdb"))) {
+
+                QFile f(dest);
+                f.open(QFile::WriteOnly);
+                f.write(dynamic_cast<const KArchiveFile*>(dir->entry(entry))->data());
+                f.close();
+            } else if(dir->entry(entry)->isDirectory()) {
+                scanDir(dynamic_cast<const KArchiveDirectory*>(dir->entry(entry)));
+            }
+        }
+    }
+
+    QUrl GeoIPManager::geoip_url = QUrl(QStringLiteral("https://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.tar.gz"));
+#endif
 
-    GeoIPManager::GeoIPManager(QObject* parent): QObject(parent), geo_ip(nullptr), decompress_thread(nullptr)
+    GeoIPManager::GeoIPManager(QObject* parent): QObject(parent)
+#ifdef HAVE_MAXMINDDB
+                                               , untar_thread(nullptr)
+#endif
     {
-#ifdef USE_SYSTEM_GEOIP
-        geo_ip = GeoIP_open_type(GEOIP_COUNTRY_EDITION, GEOIP_STANDARD);
-#else
-        geoip_data_file = QStandardPaths::locate(QStandardPaths::AppDataLocation, QStringLiteral("geoip.dat"));
+#ifdef HAVE_MAXMINDDB
+        memset(&geo_ip, 0, sizeof(geo_ip));
+        geoip_data_file = QStandardPaths::locate(QStandardPaths::AppDataLocation, QStringLiteral("GeoLite2-Country.mmdb"));
         if (geoip_data_file.isEmpty())
-            geoip_data_file = QStandardPaths::locate(QStandardPaths::AppDataLocation, QStringLiteral("GeoIP.dat"));
+            geoip_data_file = QStandardPaths::locate(QStandardPaths::AppDataLocation, QStringLiteral("geolite2-country.mmdb"));
 
         if (geoip_data_file.isEmpty())
         {
@@ -52,8 +86,8 @@ namespace kt
         }
         else
         {
-            geo_ip = GeoIP_open(QFile::encodeName(geoip_data_file).data(), 0);
-            if (geo_ip)
+            int status = MMDB_open(QFile::encodeName(geoip_data_file).data(), 0, &geo_ip);
+            if (status == MMDB_SUCCESS)
             {
                 QFileInfo fi(geoip_data_file);
                 QDateTime now = QDateTime::currentDateTime();
@@ -70,49 +104,86 @@ namespace kt
 
     GeoIPManager::~GeoIPManager()
     {
-        if (geo_ip)
-            GeoIP_delete(geo_ip);
+#ifdef HAVE_MAXMINDDB
+        if (geo_ip.filename)
+            MMDB_close(&geo_ip);
 
-        if (decompress_thread)
+        if (untar_thread)
         {
-            decompress_thread->cancel();
-            decompress_thread->wait();
-            delete decompress_thread;
+            untar_thread->wait();
+            delete untar_thread;
         }
+#endif
     }
 
-    int GeoIPManager::findCountry(const QString& addr)
-    {
-        if (!geo_ip)
-            return 0;
-        else
-            return GeoIP_id_by_name(geo_ip, addr.toLatin1().data());
-    }
+#ifndef HAVE_MAXMINDDB
+    static bool warnedAboutMissingMaxmindDB = false;
+#endif
 
-    QString GeoIPManager::countryCode(int country_id)
+    QString GeoIPManager::findCountry(const QString& addr)
     {
-        if (country_id > 0 && country_id < 247)
-            return QString::fromLatin1(GeoIP_country_code[country_id]);
-        else
-            return QString();
+#ifdef HAVE_MAXMINDDB
+        if (!geo_ip.filename)
+            return QString::null;
+
+        int gai_error, mmdb_error, status;
+        MMDB_lookup_result_s result = MMDB_lookup_string(&geo_ip, addr.toLatin1().data(), &gai_error, &mmdb_error);
+        if (gai_error || mmdb_error != MMDB_SUCCESS || !result.found_entry)
+            return QString::null;
+        MMDB_entry_data_s entry_data;
+	QString preferredLocale=QLocale::system().name().section(QChar::fromLatin1('_'), 0, 0);
+        status = MMDB_get_value(&result.entry, &entry_data, "country", "names", preferredLocale.toLatin1().data(), nullptr);
+	if (status != MMDB_SUCCESS || !entry_data.has_data || entry_data.type != MMDB_DATA_TYPE_UTF8_STRING) // Maxmind doesn't translate to every language -- fall back to English
+            status = MMDB_get_value(&result.entry, &entry_data, "country", "names", "en", nullptr);
+        if (status != MMDB_SUCCESS || !entry_data.has_data || entry_data.type != MMDB_DATA_TYPE_UTF8_STRING)
+            return QString::null;
+        char *country_utf8=strndup(entry_data.utf8_string, entry_data.data_size);
+        QString country=QString::fromUtf8(country_utf8);
+        free(country_utf8);
+        return country;
+#else
+        if (!warnedAboutMissingMaxmindDB) {
+            Out(SYS_INW | LOG_NOTICE) << "Compiled without MaxMindDB support, country lookup not available." << endl;
+            warnedAboutMissingMaxmindDB=true;
+        }
+        return QString::null;
+#endif
     }
 
-    QString GeoIPManager::countryName(int country_id)
+    QString GeoIPManager::countryCode(const QString &addr)
     {
-        if (country_id > 0 && country_id < 247)
-            return QString::fromUtf8(GeoIP_country_name[country_id]);
-        else
-            return QString();
+#ifdef HAVE_MAXMINDDB
+        if (!geo_ip.filename)
+            return QString::null;
+
+        int gai_error, mmdb_error, status;
+        MMDB_lookup_result_s result = MMDB_lookup_string(&geo_ip, addr.toLatin1().data(), &gai_error, &mmdb_error);
+        if (gai_error || mmdb_error != MMDB_SUCCESS || !result.found_entry)
+            return QString::null;
+        MMDB_entry_data_s entry_data;
+        status = MMDB_get_value(&result.entry, &entry_data, "country", "iso_code", nullptr);
+        if (status != MMDB_SUCCESS || !entry_data.has_data || entry_data.type != MMDB_DATA_TYPE_UTF8_STRING)
+            return QString::null;
+        char *country_utf8=strndup(entry_data.utf8_string, entry_data.data_size);
+        QString country=QString::fromUtf8(country_utf8);
+        free(country_utf8);
+        return country;
+#else
+        if (!warnedAboutMissingMaxmindDB) {
+            Out(SYS_INW | LOG_NOTICE) << "Compiled without MaxMindDB support, country lookup not available." << endl;
+            warnedAboutMissingMaxmindDB=true;
+        }
+        return QString::null;
+#endif
     }
 
+#ifdef HAVE_MAXMINDDB
     void GeoIPManager::downloadDataBase()
     {
-#ifndef USE_SYSTEM_GEOIP
         Out(SYS_INW | LOG_NOTICE) << "Downloading GeoIP database: " << geoip_url << endl;
         download_destination = kt::DataDir(CreateIfNotExists) + geoip_url.fileName();
         KIO::CopyJob* job = KIO::copy(geoip_url, QUrl::fromLocalFile(download_destination), KIO::Overwrite | KIO::HideProgressInfo);
         connect(job, &KIO::CopyJob::result, this, &GeoIPManager::databaseDownloadFinished);
-#endif
     }
 
     void GeoIPManager::databaseDownloadFinished(KJob* job)
@@ -123,48 +194,31 @@ namespace kt
             return;
         }
 
-        if (download_destination.endsWith(QLatin1String(".dat")) || download_destination.endsWith(QLatin1String(".DAT")))
-        {
-            Out(SYS_INW | LOG_NOTICE) << "GeoIP database downloaded, opening ...  " << endl;
-            geoip_data_file = download_destination;
-            if (geo_ip)
-            {
-                GeoIP_delete(geo_ip);
-                geo_ip = nullptr;
-            }
-            geo_ip = GeoIP_open(QFile::encodeName(geoip_data_file).data(), 0);
-            if (!geo_ip)
-                Out(SYS_INW | LOG_NOTICE) << "Failed to open GeoIP database  " << endl;
-        }
-        else
-        {
-            Out(SYS_INW | LOG_NOTICE) << "GeoIP database downloaded, decompressing ...  " << endl;
-            // decompress the file
-            decompress_thread = new bt::DecompressThread(download_destination, kt::DataDir() + QLatin1String("geoip.dat"));
-            connect(decompress_thread, &bt::DecompressThread::finished, this, &GeoIPManager::decompressFinished, Qt::QueuedConnection);
-            decompress_thread->start(QThread::IdlePriority);
-        }
+        Out(SYS_INW | LOG_NOTICE) << "GeoIP database downloaded, decompressing ...  " << endl;
+        // decompress the file
+        untar_thread = new UntarThread(download_destination, kt::DataDir() + QLatin1String("GeoLite2-Country.mmdb"));
+        connect(untar_thread, &UntarThread::finished, this, &GeoIPManager::decompressFinished, Qt::QueuedConnection);
+        untar_thread->start(QThread::IdlePriority);
     }
 
     void GeoIPManager::decompressFinished()
     {
         Out(SYS_INW | LOG_NOTICE) << "GeoIP database decompressed, opening ...  " << endl;
-        if (!decompress_thread->error())
+        geoip_data_file = kt::DataDir() + QLatin1String("GeoLite2-Country.mmdb");
+        if (geo_ip.filename)
         {
-            geoip_data_file = kt::DataDir() + QLatin1String("geoip.dat");
-            if (geo_ip)
-            {
-                GeoIP_delete(geo_ip);
-                geo_ip = nullptr;
-            }
-            geo_ip = GeoIP_open(QFile::encodeName(geoip_data_file).data(), 0);
-            if (!geo_ip)
-                Out(SYS_INW | LOG_NOTICE) << "Failed to open GeoIP database  " << endl;
+            MMDB_close(&geo_ip);
+            memset(&geo_ip, 0, sizeof(geo_ip));
+        }
+        int status = MMDB_open(QFile::encodeName(geoip_data_file).data(), 0, &geo_ip);
+        if (status != MMDB_SUCCESS) {
+            Out(SYS_INW | LOG_NOTICE) << "Failed to open GeoIP database  " << endl;
+            memset(&geo_ip, 0, sizeof(geo_ip));
         }
 
-        decompress_thread->wait();
-        delete decompress_thread;
-        decompress_thread = nullptr;
+        untar_thread->wait();
+        delete untar_thread;
+        untar_thread = nullptr;
     }
 
 
@@ -172,6 +226,7 @@ namespace kt
     {
         geoip_url = url;
     }
+#endif
 
     ///////////////////////////////////
 
diff -up ktorrent-5.1.1/plugins/infowidget/geoipmanager.h.2~ ktorrent-5.1.1/plugins/infowidget/geoipmanager.h
--- ktorrent-5.1.1/plugins/infowidget/geoipmanager.h.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/geoipmanager.h	2019-05-11 22:29:42.002192263 +0200
@@ -1,6 +1,7 @@
 /***************************************************************************
  *   Copyright (C) 2009 by Joris Guisson                                   *
  *   joris.guisson@gmail.com                                               *
+ *   Copyright (C) 2019 by Bernhard "Bero" Rosenkraenzer <bero@lindev.ch>  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -25,21 +26,30 @@
 #include <QThread>
 #include <QUrl>
 
-#ifdef USE_SYSTEM_GEOIP
-#include <GeoIP.h>
-#else
-#include "GeoIP.h"
-#endif
+#ifdef HAVE_MAXMINDDB
+#include <maxminddb.h>
 
 class KJob;
-
-namespace bt
-{
-    class DecompressThread;
-}
+class KArchiveDirectory;
+#endif
 
 namespace kt
 {
+#ifdef HAVE_MAXMINDDB
+    class UntarThread : public QThread
+    {
+        Q_OBJECT
+    public:
+        UntarThread(QString srcFile, QString destFile, QObject *parent=nullptr):QThread(parent),src(srcFile),dest(destFile) {}
+    protected:
+        void run() override;
+    private:
+        void scanDir(const KArchiveDirectory *dir);
+
+        QString src;
+        QString dest;
+    };
+#endif
 
 
     /**
@@ -57,22 +67,16 @@ namespace kt
          * @param addr The IP address
          * @return The country ID
          */
-        int findCountry(const QString& addr);
-
-        /**
-         * Get the name of the country
-         * @param country_id The country ID
-         * @return The name
-         */
-        QString countryName(int country_id);
+        QString findCountry(const QString& addr);
 
         /**
          * Get the code of the country
-         * @param country_id The country ID
+         * @param addr The IP address
          * @return The name
          */
-        QString countryCode(int country_id);
+        QString countryCode(const QString& addr);
 
+#ifdef HAVE_MAXMINDDB
         /// Get the database URL
         static QUrl geoIPUrl() {return geoip_url;}
 
@@ -87,11 +91,12 @@ namespace kt
         void decompressFinished();
 
     private:
-        GeoIP* geo_ip;
+        MMDB_s geo_ip;
         QString geoip_data_file;
         QString download_destination;
-        bt::DecompressThread* decompress_thread;
+        UntarThread* untar_thread;
         static QUrl geoip_url;
+#endif
     };
 
 
diff -up ktorrent-5.1.1/plugins/infowidget/peerviewmodel.cpp.2~ ktorrent-5.1.1/plugins/infowidget/peerviewmodel.cpp
--- ktorrent-5.1.1/plugins/infowidget/peerviewmodel.cpp.2~	2018-08-31 01:37:04.000000000 +0200
+++ ktorrent-5.1.1/plugins/infowidget/peerviewmodel.cpp	2019-05-11 22:29:42.002192263 +0200
@@ -2,6 +2,7 @@
  *   Copyright (C) 2008 by Joris Guisson and Ivan Vasic                    *
  *   joris.guisson@gmail.com                                               *
  *   ivasic@gmail.com                                                      *
+ *   Copyright (C) 2019 by Bernhard "Bero" Rosenkraenzer <bero@lindev.ch>  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -59,12 +60,8 @@ namespace kt
 
         if (geo_ip)
         {
-            int country_id = geo_ip->findCountry(stats.ip_address);
-            if (country_id > 0)
-            {
-                country = geo_ip->countryName(country_id);
-                flag = flagDB.getFlag(geo_ip->countryCode(country_id));
-            }
+            country = geo_ip->findCountry(stats.ip_address);
+            flag = flagDB.getFlag(geo_ip->countryCode(stats.ip_address).toLower());
         }
     }
 
